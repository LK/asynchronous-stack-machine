import "globals.act";
import "channel.act";
import "combinational.act";

defproc delaybuf(bool in, out)
{
  bool _x;
  prs {
     in => _x-
     _x => out-
  }
}

template<pint D>
defproc delay (bool in, out)
{
  delaybuf d[D];
  (i:D-1:d[i].out=d[i+1].in;)
  d[0].in = in;
  d[D-1].out = out;
}

/* Combinational logic for 4 bit compare -- necessitate all 4 inputs
  to be low and the delay to be high to set out.t true.
  otherwise, wait for delay high to set out.f false.
 */
defproc bundled_cmp_1 (bool go_r; dualrail c[4]; dualrail out)
{
   /* combinational logic */
   delay<4> d;
   bool _dout;
   d.in = go_r;
   prs {
      d.out => _dout-
      ~_dout & ((~c[0].f & ~c[1].f & ~c[2].f & ~c[3].f) | (~c[0].t & ~c[1].t & ~c[2].t & ~c[3].t)) => out.t+
      ~_dout & ((~c[0].f | ~c[1].f | ~c[2].f | ~c[3].f) & (~c[0].t | ~c[1].t | ~c[2].t | ~c[3].t)) => out.f+
   }
}

defproc bundled_stackadd_8 (bool go_r; dualrail v0[8]; dualrail v1[8]; dualrail out[8])
{
   /* combinational logic */
   delay<62> d;
   bool _dout;
   d.in = go_r;

   bool cout;
   bool cin;
   add8 a (,,cin,, cout);
   (; i : 8 : a.a[i] = v0[i].t; a.b[i] = v1[i].t; )

   bool _aout[8];
   prs {
      Reset -> cin-
      d.out => _dout-
      (i:8: a.out[i] => _aout[i]-
            ~_dout & ~_aout[i] => out[i].t+
            ~_dout & ~a.out[i] => out[i].f+
      )
   }
}

defproc bundled_stacksub_8 (bool go_r; dualrail v0[8]; dualrail v1[8]; dualrail out[8])
{
   /* combinational logic */
   delay<62> d;
   d.in = go_r;
   bool cout, cin, _dout;
   add8 s (,, cin,, cout);
   (; i : 8 : s.a[i] = v0[i].t; s.b[i] = v1[i].f; )

   bool _sout[8];
   prs {
      ~_Reset -> cin+
      d.out => _dout-
      (i:8: s.out[i] => _sout[i]-
	    ~_dout & ~_sout[i] => out[i].t+
	    ~_dout & ~s.out[i] => out[i].f+
      )
   }
}

defproc bundled_fblock_8 (bool go_r; dualrail c[4]; dualrail x[8], y[8]; dualrail out[8])
{
   /* combinational logic */
   delay<2> d;
   bool _dout;
   d.in = go_r;
   fblock8 fblock;
   (; i : 8 : fblock.a[i] = x[i].t; fblock.b[i] = y[i].t;)
   fblock.g0 = c[0].t;
   fblock.g1 = c[1].t;
   fblock.g2 = c[2].t;
   fblock.g3 = c[3].t;

   bool _out[8];

   prs {
      d.out => _dout-
      (i:8: ~_dout & ~fblock.out[i] => out[i].f+
            ~fblock.out[i] => _out[i]+
            ~_dout & ~_out[i] => out[i].t+
      )
   }
}

defproc bundled_is_zero_1(bool go_r; dualrail v0[12]; dualrail out) {
  bool _gor;
  prs {
    go_r => _gor-
    ~_gor & (&i:12: ~v0[i].t) -> out.t+
    ~_gor & (|i:12: ~v0[0].f) -> out.f+
    _gor -> out.t-
    _gor -> out.f-
  }
}

defproc bundled_is_less_than_zero_1(bool go_r; dualrail v0[12]; dualrail out) {
  bool _gor;
  prs {
    go_r => _gor-
    ~_gor & ~v0[11].f -> out.t+
    ~_gor & ~v0[11].t -> out.f+
    _gor -> out.t-
    _gor -> out.f-
  }
}

defproc bundled_is_reg0_1(bool go_r; dualrail v0[8]; dualrail out) {
  bool _gor;
  prs {
    go_r => _gor-
    ~_gor & ~v0[0].t & ~v0[1].t -> out.t+
    ~_gor & (~v0[0].f | ~v0[1].f) -> out.f+
    _gor -> out.t-
    _gor -> out.f-
  }
}

defproc bundled_is_reg1_1(bool go_r; dualrail v0[8]; dualrail out) {
  bool _gor;
  prs {
    go_r => _gor-
    ~_gor & ~v0[0].f & ~v0[1].t -> out.t+
    ~_gor & (~v0[0].t | ~v0[1].f) -> out.f+
    _gor -> out.t-
    _gor -> out.f-
  }
}

defproc bundled_is_reg2_1(bool go_r; dualrail v0[8]; dualrail out) {
  bool _gor;
  prs {
    go_r => _gor-
    ~_gor & ~v0[0].t & ~v0[1].f -> out.t+
    ~_gor & (~v0[0].f | ~v0[1].t) -> out.f+
    _gor -> out.t-
    _gor -> out.f-
  }
}

defproc bundled_is_reg3_1(bool go_r; dualrail v0[8]; dualrail out) {
  bool _gor;
  prs {
    go_r => _gor-
    ~_gor & ~v0[0].f & ~v0[1].f -> out.t+
    ~_gor & (~v0[0].t | ~v0[1].t) -> out.f+
    _gor -> out.t-
    _gor -> out.f-
  }
}

defproc bundled_pcincrement_12 (bool go_r; dualrail v0[12]; dualrail out[12])
{
   /* combinational logic */
   delay<100> d;
   d.in = go_r;
   bool zero[12];
   bool cout, cin, _dout;
   add12 s (,, cin,, cout);
   (; i : 12 : s.a[i] = v0[i].t; s.b[i] = zero[i]; )

   bool _sout[12];
   prs {
      ~_Reset -> cin+
      d.out => _dout-
      (i:12: Reset -> zero[i]-)
      (i:12: s.out[i] => _sout[i]-
	       ~_dout & ~_sout[i] => out[i].t+
	       ~_dout & ~s.out[i] => out[i].f+
      )
   }
}

defproc bundled_pcadd_12 (bool go_r; dualrail v0[12]; dualrail v1[8]; dualrail out[12])
{
   /* combinational logic */
   delay<100> d;
   bool _dout;
   d.in = go_r;

   bool cout, cin;
   /*bool msbs[4];*/
   bool y8, y9, y10, y11;
   add12 a (,,cin,, cout);
   (i:12: a.a[i] = v0[i].t; )
   (i:8: a.b[i] = v1[i].t; )
   /*(i:8..11: a.b[i] = msbs[i]; )*/
   a.b[8] = y8;
   a.b[9] = y9;
   a.b[10] = y10;
   a.b[11] = y11;

   bool _aout[12];
   prs {
      Reset -> cin-
      Reset -> y8-
      Reset -> y9-
      Reset -> y10-
      Reset -> y11-
      d.out => _dout-
      (i:12: a.out[i] => _aout[i]-
            ~_dout & ~_aout[i] => out[i].t+
            ~_dout & ~a.out[i] => out[i].f+
      )
   }
   /*       (i:8..11: Reset -> msbs[i]-) */
}
